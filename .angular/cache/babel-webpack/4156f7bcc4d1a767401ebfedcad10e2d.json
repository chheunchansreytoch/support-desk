{"ast":null,"code":"import { DOCUMENT, isPlatformServer, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Injector, Optional, Inject, EventEmitter, SecurityContext, Directive, ElementRef, ChangeDetectorRef, PLATFORM_ID, Renderer2, NgZone, Input, Output, Component, ViewEncapsulation, forwardRef, NgModule } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { Subscription, fromEvent } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/platform-browser';\nimport * as ɵngcc2 from '@angular/common';\nconst _c0 = [[[\"\", \"quill-editor-toolbar\", \"\"]]];\nconst _c1 = [\"[quill-editor-toolbar]\"];\nconst defaultModules = {\n  toolbar: [['bold', 'italic', 'underline', 'strike'], ['blockquote', 'code-block'], [{\n    header: 1\n  }, {\n    header: 2\n  }], [{\n    list: 'ordered'\n  }, {\n    list: 'bullet'\n  }], [{\n    script: 'sub'\n  }, {\n    script: 'super'\n  }], [{\n    indent: '-1'\n  }, {\n    indent: '+1'\n  }], [{\n    direction: 'rtl'\n  }], [{\n    size: ['small', false, 'large', 'huge']\n  }], [{\n    header: [1, 2, 3, 4, 5, 6, false]\n  }], [{\n    color: []\n  }, {\n    background: []\n  }], [{\n    font: []\n  }], [{\n    align: []\n  }], ['clean'], ['link', 'image', 'video'] // link and image, video\n  ]\n};\n\nconst getFormat = (format, configFormat) => {\n  const passedFormat = format || configFormat;\n  return passedFormat || 'html';\n};\n\nconst QUILL_CONFIG_TOKEN = new InjectionToken('config', {\n  providedIn: 'root',\n  factory: () => ({\n    modules: defaultModules\n  })\n});\nlet QuillService = /*#__PURE__*/(() => {\n  class QuillService {\n    constructor(injector, config) {\n      this.config = config;\n      this.count = 0;\n      this.document = injector.get(DOCUMENT);\n\n      if (!this.config) {\n        this.config = {\n          modules: defaultModules\n        };\n      }\n    }\n\n    getQuill() {\n      this.count++;\n\n      if (!this.Quill && this.count === 1) {\n        this.$importPromise = new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n          var _a, _b; // Quill adds events listeners on import https://github.com/quilljs/quill/blob/develop/core/emitter.js#L8\n          // We'd want to use the unpatched `addEventListener` method to have all event callbacks to be run outside of zone.\n          // We don't know yet if the `zone.js` is used or not, just save the value to restore it back further.\n\n\n          const maybePatchedAddEventListener = this.document.addEventListener; // There're 2 types of Angular applications:\n          // 1) zone-full (by default)\n          // 2) zone-less\n          // The developer can avoid importing the `zone.js` package and tells Angular that he/she is responsible for running\n          // the change detection by himself. This is done by \"nooping\" the zone through `CompilerOptions` when bootstrapping\n          // the root module. We fallback to `document.addEventListener` if `__zone_symbol__addEventListener` is not defined,\n          // this means the `zone.js` is not imported.\n          // The `__zone_symbol__addEventListener` is basically a native DOM API, which is not patched by zone.js, thus not even going\n          // through the `zone.js` task lifecycle. You can also access the native DOM API as follows `target[Zone.__symbol__('methodName')]`.\n          // eslint-disable-next-line @typescript-eslint/dot-notation\n\n          this.document.addEventListener = this.document['__zone_symbol__addEventListener'] || this.document.addEventListener;\n          const quillImport = yield import('quill');\n          this.document.addEventListener = maybePatchedAddEventListener;\n          this.Quill = quillImport.default ? quillImport.default : quillImport; // Only register custom options and modules once\n\n          (_a = this.config.customOptions) === null || _a === void 0 ? void 0 : _a.forEach(customOption => {\n            const newCustomOption = this.Quill.import(customOption.import);\n            newCustomOption.whitelist = customOption.whitelist;\n            this.Quill.register(newCustomOption, true, this.config.suppressGlobalRegisterWarning);\n          });\n          (_b = this.config.customModules) === null || _b === void 0 ? void 0 : _b.forEach(({\n            implementation,\n            path\n          }) => {\n            this.Quill.register(path, implementation, this.config.suppressGlobalRegisterWarning);\n          });\n          resolve(this.Quill);\n        }));\n      }\n\n      return this.$importPromise;\n    }\n\n  }\n\n  QuillService.ɵfac = function QuillService_Factory(t) {\n    return new (t || QuillService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(QUILL_CONFIG_TOKEN, 8));\n  };\n\n  QuillService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function QuillService_Factory() {\n      return new QuillService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(QUILL_CONFIG_TOKEN, 8));\n    },\n    token: QuillService,\n    providedIn: \"root\"\n  });\n  return QuillService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable-next-line @angular-eslint/directive-class-suffix\n\n\nlet QuillEditorBase = /*#__PURE__*/(() => {\n  class QuillEditorBase {\n    constructor(injector, elementRef, cd, domSanitizer, platformId, renderer, zone, service) {\n      this.elementRef = elementRef;\n      this.cd = cd;\n      this.domSanitizer = domSanitizer;\n      this.platformId = platformId;\n      this.renderer = renderer;\n      this.zone = zone;\n      this.service = service;\n      this.required = false;\n      this.customToolbarPosition = 'top';\n      this.sanitize = false;\n      this.styles = null;\n      this.strict = true;\n      this.customOptions = [];\n      this.customModules = [];\n      this.preserveWhitespace = false;\n      this.trimOnValidation = false;\n      this.compareValues = false;\n      this.filterNull = false;\n      /*\n      https://github.com/KillerCodeMonkey/ngx-quill/issues/1257 - fix null value set\n             provide default empty value\n      by default null\n             e.g. defaultEmptyValue=\"\" - empty string\n             <quill-editor\n        defaultEmptyValue=\"\"\n        formControlName=\"message\"\n      ></quill-editor>\n      */\n\n      this.defaultEmptyValue = null;\n      this.onEditorCreated = new EventEmitter();\n      this.onEditorChanged = new EventEmitter();\n      this.onContentChanged = new EventEmitter();\n      this.onSelectionChanged = new EventEmitter();\n      this.onFocus = new EventEmitter();\n      this.onBlur = new EventEmitter();\n      this.disabled = false; // used to store initial value before ViewInit\n\n      this.subscription = null;\n\n      this.valueGetter = (quillEditor, editorElement) => {\n        let html = editorElement.querySelector('.ql-editor').innerHTML;\n\n        if (html === '<p><br></p>' || html === '<div><br></div>') {\n          html = this.defaultEmptyValue;\n        }\n\n        let modelValue = html;\n        const format = getFormat(this.format, this.service.config.format);\n\n        if (format === 'text') {\n          modelValue = quillEditor.getText();\n        } else if (format === 'object') {\n          modelValue = quillEditor.getContents();\n        } else if (format === 'json') {\n          try {\n            modelValue = JSON.stringify(quillEditor.getContents());\n          } catch (e) {\n            modelValue = quillEditor.getText();\n          }\n        }\n\n        return modelValue;\n      };\n\n      this.valueSetter = (quillEditor, value) => {\n        const format = getFormat(this.format, this.service.config.format);\n\n        if (format === 'html') {\n          if (this.sanitize) {\n            value = this.domSanitizer.sanitize(SecurityContext.HTML, value);\n          }\n\n          return quillEditor.clipboard.convert(value);\n        } else if (format === 'json') {\n          try {\n            return JSON.parse(value);\n          } catch (e) {\n            return [{\n              insert: value\n            }];\n          }\n        }\n\n        return value;\n      };\n\n      this.selectionChangeHandler = (range, oldRange, source) => {\n        const shouldTriggerOnModelTouched = !range && !!this.onModelTouched; // only emit changes when there's any listener\n\n        if (!this.onBlur.observers.length && !this.onFocus.observers.length && !this.onSelectionChanged.observers.length && !shouldTriggerOnModelTouched) {\n          return;\n        }\n\n        this.zone.run(() => {\n          if (range === null) {\n            this.onBlur.emit({\n              editor: this.quillEditor,\n              source\n            });\n          } else if (oldRange === null) {\n            this.onFocus.emit({\n              editor: this.quillEditor,\n              source\n            });\n          }\n\n          this.onSelectionChanged.emit({\n            editor: this.quillEditor,\n            oldRange,\n            range,\n            source\n          });\n\n          if (shouldTriggerOnModelTouched) {\n            this.onModelTouched();\n          }\n\n          this.cd.markForCheck();\n        });\n      };\n\n      this.textChangeHandler = (delta, oldDelta, source) => {\n        // only emit changes emitted by user interactions\n        const text = this.quillEditor.getText();\n        const content = this.quillEditor.getContents();\n        let html = this.editorElem.querySelector('.ql-editor').innerHTML;\n\n        if (html === '<p><br></p>' || html === '<div><br></div>') {\n          html = this.defaultEmptyValue;\n        }\n\n        const trackChanges = this.trackChanges || this.service.config.trackChanges;\n        const shouldTriggerOnModelChange = (source === 'user' || trackChanges && trackChanges === 'all') && !!this.onModelChange; // only emit changes when there's any listener\n\n        if (!this.onContentChanged.observers.length && !shouldTriggerOnModelChange) {\n          return;\n        }\n\n        this.zone.run(() => {\n          if (shouldTriggerOnModelChange) {\n            this.onModelChange(this.valueGetter(this.quillEditor, this.editorElem));\n          }\n\n          this.onContentChanged.emit({\n            content,\n            delta,\n            editor: this.quillEditor,\n            html,\n            oldDelta,\n            source,\n            text\n          });\n          this.cd.markForCheck();\n        });\n      }; // eslint-disable-next-line max-len\n\n\n      this.editorChangeHandler = (event, current, old, source) => {\n        // only emit changes when there's any listener\n        if (!this.onEditorChanged.observers.length) {\n          return;\n        } // only emit changes emitted by user interactions\n\n\n        if (event === 'text-change') {\n          const text = this.quillEditor.getText();\n          const content = this.quillEditor.getContents();\n          let html = this.editorElem.querySelector('.ql-editor').innerHTML;\n\n          if (html === '<p><br></p>' || html === '<div><br></div>') {\n            html = this.defaultEmptyValue;\n          }\n\n          this.zone.run(() => {\n            this.onEditorChanged.emit({\n              content,\n              delta: current,\n              editor: this.quillEditor,\n              event,\n              html,\n              oldDelta: old,\n              source,\n              text\n            });\n            this.cd.markForCheck();\n          });\n        } else {\n          this.zone.run(() => {\n            this.onEditorChanged.emit({\n              editor: this.quillEditor,\n              event,\n              oldRange: old,\n              range: current,\n              source\n            });\n            this.cd.markForCheck();\n          });\n        }\n      };\n\n      this.document = injector.get(DOCUMENT);\n    }\n\n    static normalizeClassNames(classes) {\n      const classList = classes.trim().split(' ');\n      return classList.reduce((prev, cur) => {\n        const trimmed = cur.trim();\n\n        if (trimmed) {\n          prev.push(trimmed);\n        }\n\n        return prev;\n      }, []);\n    }\n\n    ngAfterViewInit() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (isPlatformServer(this.platformId)) {\n          return;\n        } // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n        const Quill = yield this.service.getQuill();\n        this.elementRef.nativeElement.insertAdjacentHTML(this.customToolbarPosition === 'top' ? 'beforeend' : 'afterbegin', this.preserveWhitespace ? '<pre quill-editor-element></pre>' : '<div quill-editor-element></div>');\n        this.editorElem = this.elementRef.nativeElement.querySelector('[quill-editor-element]');\n        const toolbarElem = this.elementRef.nativeElement.querySelector('[quill-editor-toolbar]');\n        const modules = Object.assign({}, this.modules || this.service.config.modules);\n\n        if (toolbarElem) {\n          modules.toolbar = toolbarElem;\n        } else if (modules.toolbar === undefined) {\n          modules.toolbar = defaultModules.toolbar;\n        }\n\n        let placeholder = this.placeholder !== undefined ? this.placeholder : this.service.config.placeholder;\n\n        if (placeholder === undefined) {\n          placeholder = 'Insert text here ...';\n        }\n\n        if (this.styles) {\n          Object.keys(this.styles).forEach(key => {\n            this.renderer.setStyle(this.editorElem, key, this.styles[key]);\n          });\n        }\n\n        if (this.classes) {\n          this.addClasses(this.classes);\n        }\n\n        this.customOptions.forEach(customOption => {\n          const newCustomOption = Quill.import(customOption.import);\n          newCustomOption.whitelist = customOption.whitelist;\n          Quill.register(newCustomOption, true);\n        });\n        this.customModules.forEach(({\n          implementation,\n          path\n        }) => {\n          Quill.register(path, implementation);\n        });\n        let bounds = this.bounds && this.bounds === 'self' ? this.editorElem : this.bounds;\n\n        if (!bounds) {\n          bounds = this.service.config.bounds ? this.service.config.bounds : this.document.body;\n        }\n\n        let debug = this.debug;\n\n        if (!debug && debug !== false && this.service.config.debug) {\n          debug = this.service.config.debug;\n        }\n\n        let readOnly = this.readOnly;\n\n        if (!readOnly && this.readOnly !== false) {\n          readOnly = this.service.config.readOnly !== undefined ? this.service.config.readOnly : false;\n        }\n\n        let defaultEmptyValue = this.defaultEmptyValue;\n\n        if (this.service.config.hasOwnProperty('defaultEmptyValue')) {\n          defaultEmptyValue = this.service.config.defaultEmptyValue;\n        }\n\n        let scrollingContainer = this.scrollingContainer;\n\n        if (!scrollingContainer && this.scrollingContainer !== null) {\n          scrollingContainer = this.service.config.scrollingContainer === null || this.service.config.scrollingContainer ? this.service.config.scrollingContainer : null;\n        }\n\n        let formats = this.formats;\n\n        if (!formats && formats === undefined) {\n          formats = this.service.config.formats ? [...this.service.config.formats] : this.service.config.formats === null ? null : undefined;\n        }\n\n        this.zone.runOutsideAngular(() => {\n          var _a, _b, _c;\n\n          this.quillEditor = new Quill(this.editorElem, {\n            bounds,\n            debug: debug,\n            formats: formats,\n            modules,\n            placeholder,\n            readOnly,\n            defaultEmptyValue,\n            scrollingContainer: scrollingContainer,\n            strict: this.strict,\n            theme: this.theme || (this.service.config.theme ? this.service.config.theme : 'snow')\n          }); // Set optional link placeholder, Quill has no native API for it so using workaround\n\n          if (this.linkPlaceholder) {\n            const tooltip = (_b = (_a = this.quillEditor) === null || _a === void 0 ? void 0 : _a.theme) === null || _b === void 0 ? void 0 : _b.tooltip;\n            const input = (_c = tooltip === null || tooltip === void 0 ? void 0 : tooltip.root) === null || _c === void 0 ? void 0 : _c.querySelector('input[data-link]');\n\n            if (input === null || input === void 0 ? void 0 : input.dataset) {\n              input.dataset.link = this.linkPlaceholder;\n            }\n          }\n        });\n\n        if (this.content) {\n          const format = getFormat(this.format, this.service.config.format);\n\n          if (format === 'text') {\n            this.quillEditor.setText(this.content, 'silent');\n          } else {\n            const newValue = this.valueSetter(this.quillEditor, this.content);\n            this.quillEditor.setContents(newValue, 'silent');\n          }\n\n          this.quillEditor.getModule('history').clear();\n        } // initialize disabled status based on this.disabled as default value\n\n\n        this.setDisabledState();\n        this.addQuillEventListeners(); // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n        // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n\n        if (!this.onEditorCreated.observers.length && !this.onValidatorChanged) {\n          return;\n        } // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n        // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n        // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n\n\n        requestAnimationFrame(() => {\n          if (this.onValidatorChanged) {\n            this.onValidatorChanged();\n          }\n\n          this.onEditorCreated.emit(this.quillEditor);\n        });\n      });\n    }\n\n    ngOnDestroy() {\n      this.dispose();\n    }\n\n    ngOnChanges(changes) {\n      if (!this.quillEditor) {\n        return;\n      }\n      /* eslint-disable @typescript-eslint/dot-notation */\n\n\n      if (changes.readOnly) {\n        this.quillEditor.enable(!changes.readOnly.currentValue);\n      }\n\n      if (changes.placeholder) {\n        this.quillEditor.root.dataset.placeholder = changes.placeholder.currentValue;\n      }\n\n      if (changes.defaultEmptyValue) {\n        this.quillEditor.root.dataset.defaultEmptyValue = changes.defaultEmptyValue.currentValue;\n      }\n\n      if (changes.styles) {\n        const currentStyling = changes.styles.currentValue;\n        const previousStyling = changes.styles.previousValue;\n\n        if (previousStyling) {\n          Object.keys(previousStyling).forEach(key => {\n            this.renderer.removeStyle(this.editorElem, key);\n          });\n        }\n\n        if (currentStyling) {\n          Object.keys(currentStyling).forEach(key => {\n            this.renderer.setStyle(this.editorElem, key, this.styles[key]);\n          });\n        }\n      }\n\n      if (changes.classes) {\n        const currentClasses = changes.classes.currentValue;\n        const previousClasses = changes.classes.previousValue;\n\n        if (previousClasses) {\n          this.removeClasses(previousClasses);\n        }\n\n        if (currentClasses) {\n          this.addClasses(currentClasses);\n        }\n      } // We'd want to re-apply event listeners if the `debounceTime` binding changes to apply the\n      // `debounceTime` operator or vice-versa remove it.\n\n\n      if (changes.debounceTime) {\n        this.addQuillEventListeners();\n      }\n      /* eslint-enable @typescript-eslint/dot-notation */\n\n    }\n\n    addClasses(classList) {\n      QuillEditorBase.normalizeClassNames(classList).forEach(c => {\n        this.renderer.addClass(this.editorElem, c);\n      });\n    }\n\n    removeClasses(classList) {\n      QuillEditorBase.normalizeClassNames(classList).forEach(c => {\n        this.renderer.removeClass(this.editorElem, c);\n      });\n    }\n\n    writeValue(currentValue) {\n      // optional fix for https://github.com/angular/angular/issues/14988\n      if (this.filterNull && currentValue === null) {\n        return;\n      }\n\n      this.content = currentValue;\n\n      if (!this.quillEditor) {\n        return;\n      }\n\n      const format = getFormat(this.format, this.service.config.format);\n      const newValue = this.valueSetter(this.quillEditor, currentValue);\n\n      if (this.compareValues) {\n        const currentEditorValue = this.quillEditor.getContents();\n\n        if (JSON.stringify(currentEditorValue) === JSON.stringify(newValue)) {\n          return;\n        }\n      }\n\n      if (currentValue) {\n        if (format === 'text') {\n          this.quillEditor.setText(currentValue);\n        } else {\n          this.quillEditor.setContents(newValue);\n        }\n\n        return;\n      }\n\n      this.quillEditor.setText('');\n    }\n\n    setDisabledState(isDisabled = this.disabled) {\n      // store initial value to set appropriate disabled status after ViewInit\n      this.disabled = isDisabled;\n\n      if (this.quillEditor) {\n        if (isDisabled) {\n          this.quillEditor.disable();\n          this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'disabled');\n        } else {\n          if (!this.readOnly) {\n            this.quillEditor.enable();\n          }\n\n          this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');\n        }\n      }\n    }\n\n    registerOnChange(fn) {\n      this.onModelChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onModelTouched = fn;\n    }\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChanged = fn;\n    }\n\n    validate() {\n      if (!this.quillEditor) {\n        return null;\n      }\n\n      const err = {};\n      let valid = true;\n      const text = this.quillEditor.getText(); // trim text if wanted + handle special case that an empty editor contains a new line\n\n      const textLength = this.trimOnValidation ? text.trim().length : text.length === 1 && text.trim().length === 0 ? 0 : text.length - 1;\n      const deltaOperations = this.quillEditor.getContents().ops;\n      const onlyEmptyOperation = deltaOperations && deltaOperations.length === 1 && ['\\n', ''].includes(deltaOperations[0].insert);\n\n      if (this.minLength && textLength && textLength < this.minLength) {\n        err.minLengthError = {\n          given: textLength,\n          minLength: this.minLength\n        };\n        valid = false;\n      }\n\n      if (this.maxLength && textLength > this.maxLength) {\n        err.maxLengthError = {\n          given: textLength,\n          maxLength: this.maxLength\n        };\n        valid = false;\n      }\n\n      if (this.required && !textLength && onlyEmptyOperation) {\n        err.requiredError = {\n          empty: true\n        };\n        valid = false;\n      }\n\n      return valid ? null : err;\n    }\n\n    addQuillEventListeners() {\n      this.dispose(); // We have to enter the `<root>` zone when adding event listeners, so `debounceTime` will spawn the\n      // `AsyncAction` there w/o triggering change detections. We still re-enter the Angular's zone through\n      // `zone.run` when we emit an event to the parent component.\n\n      this.zone.runOutsideAngular(() => {\n        this.subscription = new Subscription();\n        this.subscription.add( // mark model as touched if editor lost focus\n        fromEvent(this.quillEditor, 'selection-change').subscribe(([range, oldRange, source]) => {\n          this.selectionChangeHandler(range, oldRange, source);\n        })); // The `fromEvent` supports passing JQuery-style event targets, the editor has `on` and `off` methods which\n        // will be invoked upon subscription and teardown.\n\n        let textChange$ = fromEvent(this.quillEditor, 'text-change');\n        let editorChange$ = fromEvent(this.quillEditor, 'editor-change');\n\n        if (typeof this.debounceTime === 'number') {\n          textChange$ = textChange$.pipe(debounceTime(this.debounceTime));\n          editorChange$ = editorChange$.pipe(debounceTime(this.debounceTime));\n        }\n\n        this.subscription.add( // update model if text changes\n        textChange$.subscribe(([delta, oldDelta, source]) => {\n          this.textChangeHandler(delta, oldDelta, source);\n        }));\n        this.subscription.add( // triggered if selection or text changed\n        editorChange$.subscribe(([event, current, old, source]) => {\n          this.editorChangeHandler(event, current, old, source);\n        }));\n      });\n    }\n\n    dispose() {\n      if (this.subscription !== null) {\n        this.subscription.unsubscribe();\n        this.subscription = null;\n      }\n    }\n\n  }\n\n  QuillEditorBase.ɵfac = function QuillEditorBase_Factory(t) {\n    return new (t || QuillEditorBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(QuillService));\n  };\n\n  QuillEditorBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: QuillEditorBase,\n    inputs: {\n      required: \"required\",\n      customToolbarPosition: \"customToolbarPosition\",\n      sanitize: \"sanitize\",\n      styles: \"styles\",\n      strict: \"strict\",\n      customOptions: \"customOptions\",\n      customModules: \"customModules\",\n      preserveWhitespace: \"preserveWhitespace\",\n      trimOnValidation: \"trimOnValidation\",\n      compareValues: \"compareValues\",\n      filterNull: \"filterNull\",\n      defaultEmptyValue: \"defaultEmptyValue\",\n      valueGetter: \"valueGetter\",\n      valueSetter: \"valueSetter\",\n      format: \"format\",\n      theme: \"theme\",\n      modules: \"modules\",\n      debug: \"debug\",\n      readOnly: \"readOnly\",\n      placeholder: \"placeholder\",\n      maxLength: \"maxLength\",\n      minLength: \"minLength\",\n      formats: \"formats\",\n      scrollingContainer: \"scrollingContainer\",\n      bounds: \"bounds\",\n      trackChanges: \"trackChanges\",\n      classes: \"classes\",\n      linkPlaceholder: \"linkPlaceholder\",\n      debounceTime: \"debounceTime\"\n    },\n    outputs: {\n      onEditorCreated: \"onEditorCreated\",\n      onEditorChanged: \"onEditorChanged\",\n      onContentChanged: \"onContentChanged\",\n      onSelectionChanged: \"onSelectionChanged\",\n      onFocus: \"onFocus\",\n      onBlur: \"onBlur\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return QuillEditorBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet QuillEditorComponent = /*#__PURE__*/(() => {\n  class QuillEditorComponent extends QuillEditorBase {\n    constructor(injector, elementRef, cd, domSanitizer, platformId, renderer, zone, service) {\n      super(injector, elementRef, cd, domSanitizer, platformId, renderer, zone, service);\n    }\n\n  }\n\n  QuillEditorComponent.ɵfac = function QuillEditorComponent_Factory(t) {\n    return new (t || QuillEditorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DomSanitizer), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(QuillService));\n  };\n\n  QuillEditorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: QuillEditorComponent,\n    selectors: [[\"quill-editor\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      useExisting: forwardRef(() => QuillEditorComponent)\n    }, {\n      multi: true,\n      provide: NG_VALIDATORS,\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      useExisting: forwardRef(() => QuillEditorComponent)\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function QuillEditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c0);\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"\\n    :host {\\n      display: inline-block;\\n    }\\n    \"],\n    encapsulation: 2\n  });\n  return QuillEditorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet QuillViewHTMLComponent = /*#__PURE__*/(() => {\n  class QuillViewHTMLComponent {\n    constructor(sanitizer, service) {\n      this.sanitizer = sanitizer;\n      this.service = service;\n      this.content = '';\n      this.sanitize = false;\n      this.innerHTML = '';\n      this.themeClass = 'ql-snow';\n    }\n\n    ngOnChanges(changes) {\n      if (changes.theme) {\n        const theme = changes.theme.currentValue || (this.service.config.theme ? this.service.config.theme : 'snow');\n        this.themeClass = `ql-${theme} ngx-quill-view-html`;\n      } else if (!this.theme) {\n        const theme = this.service.config.theme ? this.service.config.theme : 'snow';\n        this.themeClass = `ql-${theme} ngx-quill-view-html`;\n      }\n\n      if (changes.content) {\n        const content = changes.content.currentValue;\n        this.innerHTML = this.sanitize ? content : this.sanitizer.bypassSecurityTrustHtml(content);\n      }\n    }\n\n  }\n\n  QuillViewHTMLComponent.ɵfac = function QuillViewHTMLComponent_Factory(t) {\n    return new (t || QuillViewHTMLComponent)(ɵngcc0.ɵɵdirectiveInject(DomSanitizer), ɵngcc0.ɵɵdirectiveInject(QuillService));\n  };\n\n  QuillViewHTMLComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: QuillViewHTMLComponent,\n    selectors: [[\"quill-view-html\"]],\n    inputs: {\n      content: \"content\",\n      sanitize: \"sanitize\",\n      theme: \"theme\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[1, \"ql-container\", 3, \"ngClass\"], [1, \"ql-editor\", 3, \"innerHTML\"]],\n    template: function QuillViewHTMLComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelement(1, \"div\", 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.themeClass);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"innerHTML\", ctx.innerHTML, ɵngcc0.ɵɵsanitizeHtml);\n      }\n    },\n    directives: [ɵngcc2.NgClass],\n    styles: [\"\\n.ql-container.ngx-quill-view-html {\\n  border: 0;\\n}\\n\"],\n    encapsulation: 2\n  });\n  return QuillViewHTMLComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet QuillViewComponent = /*#__PURE__*/(() => {\n  class QuillViewComponent {\n    constructor(elementRef, renderer, zone, service, domSanitizer, platformId) {\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.zone = zone;\n      this.service = service;\n      this.domSanitizer = domSanitizer;\n      this.platformId = platformId;\n      this.sanitize = false;\n      this.strict = true;\n      this.customModules = [];\n      this.customOptions = [];\n      this.preserveWhitespace = false;\n      this.onEditorCreated = new EventEmitter();\n\n      this.valueSetter = (quillEditor, value) => {\n        const format = getFormat(this.format, this.service.config.format);\n        let content = value;\n\n        if (format === 'text') {\n          quillEditor.setText(content);\n        } else {\n          if (format === 'html') {\n            if (this.sanitize) {\n              value = this.domSanitizer.sanitize(SecurityContext.HTML, value);\n            }\n\n            content = quillEditor.clipboard.convert(value);\n          } else if (format === 'json') {\n            try {\n              content = JSON.parse(value);\n            } catch (e) {\n              content = [{\n                insert: value\n              }];\n            }\n          }\n\n          quillEditor.setContents(content);\n        }\n      };\n    }\n\n    ngOnChanges(changes) {\n      if (!this.quillEditor) {\n        return;\n      }\n\n      if (changes.content) {\n        this.valueSetter(this.quillEditor, changes.content.currentValue);\n      }\n    }\n\n    ngAfterViewInit() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (isPlatformServer(this.platformId)) {\n          return;\n        } // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n        const Quill = yield this.service.getQuill();\n        const modules = Object.assign({}, this.modules || this.service.config.modules);\n        modules.toolbar = false;\n        this.customOptions.forEach(customOption => {\n          const newCustomOption = Quill.import(customOption.import);\n          newCustomOption.whitelist = customOption.whitelist;\n          Quill.register(newCustomOption, true);\n        });\n        this.customModules.forEach(({\n          implementation,\n          path\n        }) => {\n          Quill.register(path, implementation);\n        });\n        let debug = this.debug;\n\n        if (!debug && debug !== false && this.service.config.debug) {\n          debug = this.service.config.debug;\n        }\n\n        let formats = this.formats;\n\n        if (!formats && formats === undefined) {\n          formats = this.service.config.formats ? Object.assign({}, this.service.config.formats) : this.service.config.formats === null ? null : undefined;\n        }\n\n        const theme = this.theme || (this.service.config.theme ? this.service.config.theme : 'snow');\n        this.elementRef.nativeElement.insertAdjacentHTML('afterbegin', this.preserveWhitespace ? '<pre quill-view-element></pre>' : '<div quill-view-element></div>');\n        this.editorElem = this.elementRef.nativeElement.querySelector('[quill-view-element]');\n        this.zone.runOutsideAngular(() => {\n          this.quillEditor = new Quill(this.editorElem, {\n            debug: debug,\n            formats: formats,\n            modules,\n            readOnly: true,\n            strict: this.strict,\n            theme\n          });\n        });\n        this.renderer.addClass(this.editorElem, 'ngx-quill-view');\n\n        if (this.content) {\n          this.valueSetter(this.quillEditor, this.content);\n        } // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n        // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n\n\n        if (!this.onEditorCreated.observers.length) {\n          return;\n        } // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n        // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n        // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n\n\n        requestAnimationFrame(() => {\n          this.onEditorCreated.emit(this.quillEditor);\n        });\n      });\n    }\n\n  }\n\n  QuillViewComponent.ɵfac = function QuillViewComponent_Factory(t) {\n    return new (t || QuillViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(QuillService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID));\n  };\n\n  QuillViewComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: QuillViewComponent,\n    selectors: [[\"quill-view\"]],\n    inputs: {\n      sanitize: \"sanitize\",\n      strict: \"strict\",\n      customModules: \"customModules\",\n      customOptions: \"customOptions\",\n      preserveWhitespace: \"preserveWhitespace\",\n      format: \"format\",\n      theme: \"theme\",\n      modules: \"modules\",\n      debug: \"debug\",\n      formats: \"formats\",\n      content: \"content\"\n    },\n    outputs: {\n      onEditorCreated: \"onEditorCreated\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function QuillViewComponent_Template(rf, ctx) {},\n    styles: [\"\\n.ql-container.ngx-quill-view {\\n  border: 0;\\n}\\n\"],\n    encapsulation: 2\n  });\n  return QuillViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet QuillModule = /*#__PURE__*/(() => {\n  class QuillModule {\n    static forRoot(config) {\n      return {\n        ngModule: QuillModule,\n        providers: [{\n          provide: QUILL_CONFIG_TOKEN,\n          useValue: config\n        }]\n      };\n    }\n\n  }\n\n  QuillModule.ɵfac = function QuillModule_Factory(t) {\n    return new (t || QuillModule)();\n  };\n\n  QuillModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: QuillModule\n  });\n  QuillModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return QuillModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(QuillModule, {\n    declarations: function () {\n      return [QuillEditorComponent, QuillViewComponent, QuillViewHTMLComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [QuillEditorComponent, QuillViewComponent, QuillViewHTMLComponent];\n    }\n  });\n})();\n/*\n * Public API Surface of ngx-quill\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { QUILL_CONFIG_TOKEN, QuillEditorBase, QuillEditorComponent, QuillModule, QuillService, QuillViewComponent, QuillViewHTMLComponent, defaultModules }; //# sourceMappingURL=ngx-quill.js.map","map":null,"metadata":{},"sourceType":"module"}